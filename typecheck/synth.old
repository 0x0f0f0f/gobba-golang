package typecheck

import (
	"github.com/0x0f0f0f/gobba-golang/ast"
)

// This file contains definitions for synthesization rules

// TODO SynthesizesTo
func (c Context) SynthesizesTo(exp ast.Expression) (ast.TypeValue, Context, error) {
	c.debugSection("synth", exp.String())
	switch ve := exp.(type) {
	case *ast.UnitLiteral: // Rule 1I=>
		c.debugRuleOut("1I=>")
		return &ast.TyUnit{}, c, nil
	case *ast.IntegerLiteral: // Rule intI=>
		c.debugRuleOut("intI=>")
		return ast.NewTyUnVar("int"), c, nil
	case *ast.FloatLiteral: // Rule floatI=>
		c.debugRuleOut("floatI=>")
		return ast.NewTyUnVar("float"), c, nil

	case *ast.ComplexLiteral: // Rule complexI=>
		c.debugRuleOut("complexI=>")
		return ast.NewTyUnVar("complex"), c, nil

	case *ast.BoolLiteral: // Rule boolI=>
		c.debugRuleOut("boolI=>")
		return ast.NewTyUnVar("bool"), c, nil

	case *ast.StringLiteral: // Rule stringI=>
		c.debugRuleOut("stringI=>")
		return ast.NewTyUnVar("string"), c, nil

	case *ast.RuneLiteral: // Rule runeI=>
		c.debugRuleOut("runeI=>")
		return ast.NewTyUnVar("rune"), c, nil

	case *ast.ExprIdentifier:
		// Rule Var
		c.debugRuleOut("Var")
		annot := c.GetAnnotation(ve.Identifier)
		if annot == nil {
			c.debugRuleFail("Var")
			return nil, c, c.notInContextError(ve.Identifier)
		}
		c.debugRuleOut("Var")
		return *annot, c, nil
	case *ast.ExprIf:
		// Rules ifthen<:else=> and ifelse<:then=> share the first
		// 3 premises
		c.debugRule("ifthen<:else=> or ifelse<:then=>")

		gamma1, err := c.CheckAgainst(ve.Condition, ast.NewTyUnVar("bool"))
		if err != nil {
			c.debugRuleFail("ifthen<:else=> or ifelse<:then=>")
			return nil, c, err
		}
		thent, theta, err := gamma1.SynthesizesTo(ve.Consequence)
		if err != nil {
			c.debugRuleFail("ifthen<:else=> or ifelse<:then=>")
			return nil, c, err
		}
		elset, theta1, err := theta.SynthesizesTo(ve.Alternative)
		if err != nil {
			c.debugRuleFail("ifthen<:else=> or ifelse<:then=>")
			return nil, c, err
		}

		// Try to see if thent <: elset
		var delta Context
		delta, err = theta1.Subtype(thent, elset)
		if err != nil {
			// Try other case where elset <: thent
			delta, err = theta1.Subtype(elset, thent)
			if err != nil {
				c.debugRuleFail("ifthen<:else=> or ifelse<:then=>")
				return nil, c, c.expectedSameTypeIfBranches(thent, elset)
			}
			// Rule ifelse<:then=>
			// thent is a supertype of elset
			delta.debugRuleOut("ifelse<:then=>")

			return thent, delta, nil
		}
		// Rule ifthen<:else=>
		// elset is a supertype of thent
		delta.debugRuleOut("ifthen<:else=>")
		return elset, delta, nil

	case *ast.ExprInfix:
		return c.synthInfixExpr(ve)
	case *ast.ExprPrefix:
		return c.synthPrefixExpr(ve)
	case *ast.ExprLambda:
		// Rule ->l=>
		c.debugRule("->I=>")

		alpha := ast.GenUID("α")
		beta := ast.GenUID("β")
		alphaext := &ast.TyExVar{
			Identifier: alpha,
		}
		betaext := &ast.TyExVar{
			Identifier: beta,
		}
		alphaexv := &CtxExSort{
			Identifier: alpha,
		}
		betaexv := &CtxExSort{
			Identifier: beta,
		}
		annot := &TypeAnnotation{
			Identifier: ve.Param.Identifier,
			Value:      alphaext,
		}
		gamma := c.InsertHead(annot).InsertHead(betaexv).InsertHead(alphaexv)
		delta, err := gamma.CheckAgainst(ve.Body, betaext)
		if err != nil {
			c.debugRuleFail("->I=>")
			return nil, c, err
		}

		funtype := &ast.TyLambda{Domain: alphaext, Codomain: betaext}
		deltadrop := delta.Drop(annot)
		deltadrop.debugRuleOut("->I=>")

		return funtype, deltadrop, nil

	case *ast.ExprRec:
		// Rule fixI=>
		c.debugRule("fixI=>")

		alpha := ast.GenUID("α")
		beta := ast.GenUID("β")
		alphaext := &ast.TyExVar{
			Identifier: alpha,
		}
		betaext := &ast.TyExVar{
			Identifier: beta,
		}
		alphaexv := &CtxExSort{
			Identifier: alpha,
		}
		betaexv := &CtxExSort{
			Identifier: beta,
		}
		annot := &TypeAnnotation{
			Identifier: ve.Name.Identifier,
			Value:      alphaext,
		}
		gamma := c.InsertHead(annot).InsertHead(betaexv).InsertHead(alphaexv)
		delta, err := gamma.CheckAgainst(ve.Body, betaext)
		if err != nil {
			c.debugRuleFail("fixI=>")
			return nil, c, err
		}
		// funtype := &ast.LambdaType{Domain: alphaext, Codomain: betaext}
		deltadrop := delta.Drop(annot)
		deltadrop.debugRuleOut("fixI=>")

		return betaext, deltadrop, nil
	case *ast.ExprApply:
		// Rule ->E
		c.debugRule("->E")

		// _, gamma1, err := c.SynthesizesTo(ve.Arg)

		a, theta, err := c.SynthesizesTo(ve.Function)
		if err != nil {
			return nil, c, err
		}
		theta.debugRuleOut("->E")
		return theta.ApplicationSynthesizesTo(theta.Apply(a), ve.Arg)
	case *ast.ExprAnnot:
		if c.IsWellFormed(ve.Type) {
			// Rule Anno
			c.debugRule("Anno")
			delta, err := c.CheckAgainst(ve.Body, ve.Type)
			if err != nil {
				c.debugRuleFail("Anno")
				return nil, c, err
			}

			delta.debugRuleOut("Anno")
			return ve.Type, delta, nil

		}
	}
	return nil, c, c.synthError(exp)
}

func (c Context) ApplicationSynthesizesTo(
	ty ast.TypeValue,
	exp ast.Expression) (ast.TypeValue, Context, error) {

	switch vty := ty.(type) {
	case *ast.TyExVar:
		// Rule α^App
		c.debugRule("α^App")

		idexv := &CtxExSort{Identifier: vty.Identifier}
		alpha1 := ast.GenUID("α")
		alpha2 := ast.GenUID("α")
		alpha1exv := &CtxExSort{Identifier: alpha1}
		alpha2exv := &CtxExSort{Identifier: alpha2}
		alpha1ext := &ast.TyExVar{Identifier: alpha1}
		alpha2ext := &ast.TyExVar{Identifier: alpha2}

		var funt ast.TypeValue = &ast.TyLambda{
			Domain:   alpha1ext,
			Codomain: alpha2ext,
		}
		solvedexv := &CtxExSort{
			Identifier: vty.Identifier,
			Value:      &funt,
		}

		gamma := c.Insert(idexv, []CtxValue{
			alpha2exv,
			alpha1exv,
			solvedexv,
		})

		delta, err := gamma.CheckAgainst(exp, alpha1ext)
		if err != nil {
			c.debugRuleFail("α^App")
			return nil, c, err
		}

		delta.debugRuleOut("α^App")
		return alpha2ext, delta, nil
	case *ast.TyForAll:
		// Rule ∀App
		c.debugRule("∀App")

		alpha := ast.GenUID("α")
		alphaexv := &CtxExSort{Identifier: alpha}
		alphaext := &ast.TyExVar{Identifier: alpha}
		gamma := c.InsertHead(alphaexv)
		sub_a := Substitution(vty.Type, alphaext, vty.Identifier)

		gamma.debugRuleOut("∀App")
		return gamma.ApplicationSynthesizesTo(sub_a, exp)
	case *ast.TyLambda:
		// Rule ->App
		c.debugRule("->App")

		delta, err := c.CheckAgainst(exp, vty.Domain)
		if err != nil {
			c.debugRuleFail("->App")
			return nil, c, err
		}
		return vty.Codomain, delta, nil
	}

	return nil, c, c.synthError(exp)
}

// TODO add types to AST nodes
func (c Context) SynthExpr(exp ast.Expression) (ast.TypeValue, error) {
	t, nc, err := c.SynthesizesTo(exp)
	if err != nil {
		c.debugErr(err)
		return nil, err
	}
	nc.debugSynth(exp, t, true)

	t = nc.Apply(t)
	nc.debugSynth(exp, t, false)
	return t, nil
}
